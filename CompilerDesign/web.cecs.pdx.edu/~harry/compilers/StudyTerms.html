<html>
<head>
<title>CS 321: Terminology</title>
</head>
<h1>The Terminology of CS-321</h1>
Back to 
<A HREF="syllabus.html"> Course Syllabus</A> <br>
<br>
abstract syntax tree
<br>
ACTION / GOTO tables
<br>
Ada (a programming language)
<br>
alphabet (&#931;)
<br>
ambiguous
<br>
assembler / assembly language
<br>
associative / associativity
<br>
AST
<br>
attributes
<br>
back end of compiler
<br>
basic types (primitive types)
<br>
BNF
<br>
boolean
<br>
bottom-up
<br>
CFG
<br>
checker / type-checking phase
<br>
code generation
<br>
commutative / commutativity
<br>
compiler / compilation
<br>
concatenation
<br>
constructed types / type constructors
<br>
context free grammar
<br>
cycles (in graphs)
<br>
DAG
<br>
declaration (vs. definition)
<br>
definition (vs. declaration)
<br>
derivation
<br>
deterministic finite state automaton
<br>
DFA
<br>
directed acyclic graph
<br>
dynamically typed language
<br>
empty set
<br>
empty string
<br>
epsilon
<br>
epsilon edges / &#949;-edges
<br>
equivalence (or regular expressions)
<br>
expression / term / factor
<br>
final state (accept state) of an FSA
<br>
finite state machine / finite state automaton
<br>
FIRST set
<br>
front end of compiler
<br>
FOLLOW set
<br>
FSA (finite state automaton)
<br>
function type (DomainType --> RangeType)
<br>
grammar
<br>
graph / node / edge
<br>
handle
<br>
infix
<br>
inherited attributes
<br>
interior node
<br>
interpreter
<br>
item
<br>
Kleene closure
<br>
L U M  ("union of languages)
<br>
L *
<br>
L M  ("concatenation of languages")
<br>
L(G)
<br>
LALR
<br>
language (as set of strings)
<br>
leaf node
<br>
lefthand / righthand side (e.g., of CFG rule)
<br>
leftmost derivation
<br>
left-recursion / left-recursive rule
<br>
lexeme
<br>
lexer
<br>
lexical / syntactic
<br>
lexical analyzer
<br>
lexical level
<br>
LL
<br>
LL(1)
<br>
LL(k)
<br>
lookahead
<br>
LR
<br>
LR(0) item
<br>
LR(1)
<br>
LR(1) item
<br>
LR(k)
<br>
l-value
<br>
machine language / machine code
<br>
minimal DFA (minimum state DFA)
<br>
ML (a programming language used in examples)
<br>
NFA
<br>
non-deterministic finite state automaton
<br>
non-terminal
<br>
operand
<br>
operator
<br>
optimization (a phase of the compiler)
<br>
overloaded operator / function
<br>
parameter vs. argument
<br>
parse / parsing / parser
<br>
parse tree / derivation tree
<br>
Pascal / Fortran / C / C++ / Java
<br>
PCAT
<br>
phases (of compiler)
<br>
polymorphic types
<br>
positive closure
<br>
postfix notation
<br>
precedence (of operators)
<br>
predictive parsing
<br>
prefix (expression notation)
<br>
prefix (of a string)
<br>
production (in CFG)
<br>
recursive (routine / function)
<br>
recursive descent parsing
<br>
recursive transition diagrams
<br>
recursion
<br>
regular expression
<br>
regular language
<br>
regular set
<br>
return type (of a function)
<br>
rightmost derivation
<br>
right-recursion / right-recursive rule
<br>
rule (in CFG)
<br>
runtime vs. compile-time
<br>
r-value
<br>
S-attributed definitions
<br>
scope
<br>
semantics
<br>
set / intersection / union / member / subset
<br>
shift / reduce / accept / error
<br>
short-circuit operators
<br>
SLR
<br>
source language
<br>
stack
<br>
start state (of a finite state machine)
<br>
start symbol (of a CFG)
<br>
statement / loop / body / if-stmt / while-stmt / etc.
<br>
states (in DFA)
<br>
states (in LR parser)
<br>
static vs. dynamic
<br>
statically typed language
<br>
string (of symbols from an alphabet)
<br>
string table
<br>
strongly typed language
<br>
structural type equivalence vs. name equivalence
<br>
subset / proper subset / superset / proper superset
<br>
substitution
<br>
suffix
<br>
symbol table
<br>
syntax
<br>
syntax-directed definitions
<br>
synthesized attributes
<br>
target language
<br>
terminal
<br>
Thompson's Construction
<br>
token
<br>
top-down
<br>
transitions (edges in FSA)
<br>
transition diagrams
<br>
translation scheme
<br>
tree / node / parent / children
<br>
type checking
<br>
type coercion
<br>
type conversion
<br>
type expressions
<br>
type inference
<br>
type variables
<br>
unifier / most-general unifier
<br>
unify / unification
<br>
viable prefix
<br>
void / non-void (functions)
<br>
white space
<br>
YACC
<br>
&#949; (empty string)
<br>
&#949;-transitions
<br>
&#949;-closure
<br>
[upside down A] (universal quantification)
<br>
[upside down E] (existential quantification)
<br>
</body>
</html>
